---
title: "TypeScript 5.0 고급 패턴과 실전 활용법"
date: "2024-12-05"
description: "TypeScript 5.0의 새로운 기능과 실무에서 활용할 수 있는 고급 패턴들을 소개합니다."
tags: ["TypeScript", "JavaScript", "Type System", "Programming"]
category: "Programming"
thumbnail: "/images/typescript-5-thumbnail.jpg"
readingTime: "20분"
draft: false
---

# TypeScript 5.0 고급 패턴과 실전 활용법

TypeScript 5.0이 출시되면서 타입 시스템이 한층 더 강력해졌습니다. 이번 포스트에서는 새로운 기능들과 실무에서 활용 가능한 고급 패턴들을 소개합니다.

## 1. Decorators (Stage 3)

드디어 데코레이터가 정식으로 지원됩니다:

```typescript
// 클래스 데코레이터
function Component(config: ComponentConfig) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      selector = config.selector;
      template = config.template;
    };
  };
}

// 메서드 데코레이터
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`Result:`, result);
    return result;
  };
}

@Component({
  selector: "app-user",
  template: "<div>User Component</div>",
})
class UserComponent {
  @Log
  getUserData(id: number) {
    return { id, name: "John Doe" };
  }
}
```

## 2. const Type Parameters

제네릭 타입 파라미터에 const를 사용할 수 있습니다:

```typescript
// Before
declare function defineRoute<T>(route: T): T;
const routes = defineRoute({
  home: "/",
  about: "/about",
}); // type: { home: string; about: string }

// After (TypeScript 5.0)
declare function defineRoute<const T>(route: T): T;
const routes = defineRoute({
  home: "/",
  about: "/about",
}); // type: { readonly home: "/"; readonly about: "/about" }
```

## 3. 향상된 Enum

Enum이 더 유연해졌습니다:

```typescript
// Computed enum members
const enum HttpStatus {
  OK = 200,
  Created = OK + 1,
  Accepted = Created + 1,
  NoContent = 204,
  BadRequest = 400,
  NotFound = BadRequest + 4,
}

// Template literal enum
enum LogLevel {
  Error = "ERROR",
  Warning = "WARNING",
  Info = "INFO",
  Debug = "DEBUG",
}

type LogMessage = `[${LogLevel}]: ${string}`;

const log: LogMessage = "[ERROR]: Something went wrong";
```

## 4. satisfies 연산자 활용

타입 추론을 유지하면서 타입 체크:

```typescript
type ColorConfig = {
  [key: string]: string | { r: number; g: number; b: number };
};

const colors = {
  red: "#ff0000",
  green: "#00ff00",
  blue: { r: 0, g: 0, b: 255 },
} satisfies ColorConfig;

// 타입이 정확히 추론됨
colors.red.toUpperCase(); // OK
colors.blue.r; // OK
```

## 5. 고급 타입 유틸리티

### Branded Types

```typescript
type UserId = string & { __brand: "UserId" };
type PostId = string & { __brand: "PostId" };

function getUserById(id: UserId) {
  /* ... */
}
function getPostById(id: PostId) {
  /* ... */
}

const userId = "user123" as UserId;
const postId = "post456" as PostId;

getUserById(userId); // OK
getUserById(postId); // Error!
```

### Template Literal Types 고급 활용

```typescript
type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";
type APIEndpoint = "/users" | "/posts" | "/comments";

type APIRoute = `${HTTPMethod} ${APIEndpoint}`;
// "GET /users" | "GET /posts" | ... | "DELETE /comments"

type ExtractMethod<T> = T extends `${infer Method} ${string}` ? Method : never;
type Method = ExtractMethod<"GET /users">; // "GET"
```

### Conditional Types 패턴

```typescript
// DeepPartial 구현
type DeepPartial<T> = T extends object
  ? {
      [P in keyof T]?: DeepPartial<T[P]>;
    }
  : T;

// DeepReadonly 구현
type DeepReadonly<T> = T extends object
  ? {
      readonly [P in keyof T]: DeepReadonly<T[P]>;
    }
  : T;

// 함수 파라미터 추출
type Parameters<T> = T extends (...args: infer P) => any ? P : never;
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
```

## 6. 타입 안전한 Builder 패턴

```typescript
class QueryBuilder<T = {}> {
  private query: T;

  constructor(query: T = {} as T) {
    this.query = query;
  }

  select<K extends string>(fields: K[]): QueryBuilder<T & { select: K[] }> {
    return new QueryBuilder({ ...this.query, select: fields });
  }

  where<W>(conditions: W): QueryBuilder<T & { where: W }> {
    return new QueryBuilder({ ...this.query, where: conditions });
  }

  orderBy<O>(field: O): QueryBuilder<T & { orderBy: O }> {
    return new QueryBuilder({ ...this.query, orderBy: field });
  }

  build(): T {
    return this.query;
  }
}

const query = new QueryBuilder()
  .select(["id", "name"])
  .where({ age: { gt: 18 } })
  .orderBy("createdAt")
  .build();
// 타입이 정확히 추론됨!
```

## 7. 타입 안전한 Event Emitter

```typescript
type EventMap = {
  "user:login": { userId: string; timestamp: Date };
  "user:logout": { userId: string };
  "data:update": { table: string; id: number };
};

class TypedEventEmitter<T extends Record<string, any>> {
  private listeners: Map<keyof T, Set<(data: any) => void>> = new Map();

  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(listener);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach((listener) => listener(data));
    }
  }
}

const emitter = new TypedEventEmitter<EventMap>();

emitter.on("user:login", (data) => {
  console.log(data.userId); // 타입 체크 OK
  console.log(data.timestamp); // 타입 체크 OK
});

emitter.emit("user:login", {
  userId: "user123",
  timestamp: new Date(),
}); // OK
```

## 8. 실전 예제: 타입 안전한 API 클라이언트

```typescript
type APISchema = {
  "/users": {
    GET: {
      response: User[];
    };
    POST: {
      body: CreateUserDto;
      response: User;
    };
  };
  "/users/:id": {
    GET: {
      params: { id: string };
      response: User;
    };
    PUT: {
      params: { id: string };
      body: UpdateUserDto;
      response: User;
    };
  };
};

class TypedAPIClient<Schema> {
  async request<Path extends keyof Schema, Method extends keyof Schema[Path]>(path: Path, method: Method, config?: Schema[Path][Method] extends { body: any } ? { body: Schema[Path][Method]["body"] } : Schema[Path][Method] extends { params: any } ? { params: Schema[Path][Method]["params"] } : {}): Promise<Schema[Path][Method] extends { response: any } ? Schema[Path][Method]["response"] : void> {
    // 실제 구현
    const response = await fetch(/* ... */);
    return response.json();
  }
}

const api = new TypedAPIClient<APISchema>();

// 타입이 완벽하게 추론됨!
const users = await api.request("/users", "GET");
const newUser = await api.request("/users", "POST", {
  body: { name: "John", email: "john@example.com" },
});
```

## 9. 성능 최적화 팁

### 타입 계산 최적화

```typescript
// Bad - 매번 계산
type BadUnion<T> = T extends any[] ? T[number] : T;

// Good - 캐시 활용
type CachedUnion<T> = T extends readonly [...infer Items] ? Items[number] : T;
```

### 조건부 타입 최적화

```typescript
// 분산 조건부 타입 활용
type IsArray<T> = T extends any[] ? true : false;
type Test = IsArray<string | number[]>; // false | true
```

## 10. 디버깅 팁

```typescript
// 타입 디버깅용 유틸리티
type Debug<T> = { [K in keyof T]: T[K] };
type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;

// 복잡한 타입을 펼쳐서 확인
type ComplexType = Debug<SomeComplicatedType>;
```

## 마무리

TypeScript 5.0은 더 강력하고 표현력 있는 타입 시스템을 제공합니다. 이러한 고급 패턴들을 활용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.

다음 포스트에서는 TypeScript를 활용한 모노레포 구성과 프로젝트 구조에 대해 알아보겠습니다.

## 참고 자료

- [TypeScript 5.0 Release Notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Type Challenges](https://github.com/type-challenges/type-challenges)
